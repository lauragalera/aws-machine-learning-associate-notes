# Comparing and Selecting the Right Model or Algorithm

Selecting the most suitable model depends on the **use case**, **data characteristics**, and **business requirements**. No single model is best for all tasks ‚Äî each has trade-offs.

## Models

### Random Forest Cut (RFC) Algorithm

Amazon SageMaker Random Cut Forest (RCF) is an unsupervised algorithm for detecting anomalous data points within a data set. These are observations which diverge from otherwise well-structured or patterned data. Anomalies can manifest as unexpected spikes in time series data, breaks in periodicity, or unclassifiable data points. They are easy to describe in that, when viewed in a plot, they are often easily distinguishable from the "regular" data. Including these anomalies in a data set can drastically increase the complexity of a machine learning task since the "regular" data can often be described with a simple model.

Random Cut Forest (RCF) is specifically designed for detecting anomalies in data. This algorithm excels at identifying unexpected patterns in sensor data that could indicate the early stages of equipment failure. It‚Äôs particularly well-suited for scenarios where you need to react to unusual behaviors in near-real-time.

It is unsupervised. It may not leverage the labeled data effectively.

### DeepAR Algorithm

DeepAR is designed for forecasting future time series data, which could be useful for predicting future equipment behavior. However, it is not primarily used for anomaly detection, which is critical for identifying unusual patterns that precede failures.

 DeepAR is specifically designed for forecasting time-series data by leveraging deep learning to model complex temporal patterns and dependencies, making it ideal for predicting future health risks from sensor data.

### Linear Learner

Amazon SageMaker Linear Learner is ideal for supervised learning tasks like binary classification (e.g., churn prediction). It is specifically designed to handle class imbalance by adjusting class weights. Linear Learner ensures that the minority class (churned customers) is adequately represented during training. It minimizes operational effort as Linear Learner is straightforward to use, optimized for AWS, and requires less hyperparameter tuning compared to other complex algorithms.

Linear Learner could be used for classification tasks, but predicting maintenance needs often involves detecting subtle anomalies rather than simple classification. Additionally, a binary classification model might not capture the complex patterns associated with potential failures.

It may not be as effective in capturing complex patterns in the data as more sophisticated algorithms like XGBoost.

 The Linear Learner algorithm in Amazon SageMaker includes a built-in 'class_weights' parameter that allows you to assign different weights to classes, effectively handling imbalanced datasets by emphasizing underrepresented classes during training.
### Time Series K-Means Algorithm

Time Series K-Means can cluster similar time series patterns, but clustering alone does not provide the precision needed for real-time anomaly detection, which is crucial for predictive maintenance.

### XGBoost algorithm

The XGBoost (eXtreme Gradient Boosting) is a popular and efficient open-source implementation of the gradient boosted trees algorithm. Gradient boosting is a supervised learning algorithm that tries to accurately predict a target variable by combining multiple estimates from a set of simpler models. The XGBoost algorithm performs well in machine learning competitions for the following reasons:

Its robust handling of a variety of data types, relationships, distributions.

The variety of hyperparameters that you can fine-tune.

XGBoost is a powerful gradient boosting algorithm that excels in structured data problems, such as fraud detection. It allows for custom objective functions, making it highly suitable for optimizing precision and recall, which **are critical in imbalanced datasets**. Additionally, XGBoost has built-in techniques for handling class imbalance, such as scale_pos_weight.

While XGBoost is a powerful algorithm for general-purpose machine learning tasks, it is not specifically designed for recommendation systems.

XGBoost and overfitting: Reducing the max_depth parameter effectively limits the complexity of the decision trees, preventing the model from fitting noise and thus improving its ability to generalize to unseen data.

### K-Nearest Neighbors
K-Nearest Neighbors (k-NN) can classify based on similarity, but it does not scale well with large datasets and may struggle with the high-dimensional, imbalanced nature of the data in this context.

### Factorization Machines algorithm

The Factorization Machines algorithm is a general-purpose supervised learning algorithm that you can use for both classification and regression tasks. It is an extension of a linear model that is designed to capture interactions between features within high dimensional sparse datasets economically. For example, in a click prediction system, the Factorization Machines model can capture click rate patterns observed when ads from a certain ad-category are placed on pages from a certain page-category. **Factorization machines are a good choice for tasks dealing with high dimensional sparse datasets, such as click prediction and item recommendation**.

Factorization Machines is well-suited for collaborative filtering. It excels at modeling sparse user-item interactions, making it ideal for large-scale recommendation systems where there are many users and items but relatively few interactions for each user-item pair. This algorithm can effectively capture latent factors to provide personalized recommendations.

## Key Considerations When Selecting a Model

### 1. **Use Case Understanding**
- Always start by identifying what you want to solve.
- Choose simpler models like **Logistic Regression** when interpretability is important.
- Choose more complex models like **Neural Networks** when you need high accuracy on non-linear data.

## Algorithm Trade-offs

### **Performance Metrics**
- **Accuracy**: % of correct predictions. It can be misleading in imbalanced datasets.
- **Precision**: TP / (TP + FP). It measures how many predicted positives are actually positive, helping reduce false positives
- **Recall**: TP / (TP + FN). It measures how many actual positives are correctly identified, helping reduce false negatives.
- **F1 Score**: Harmonic mean of Precision & Recall  
- **AUC (Area Under the Curve)**: Binary classification quality  
- **MAE (Mean Absolute Error)**: Regression error measure  

‚ö†Ô∏è Complex models like **CNNs** or **Transformers** offer better performance but **need more computational power**.

### **Scalability**
- Related to **training and inference speed**
- **Tree-based models** (e.g., Random Forest, XGBoost):
  - Scale well with large datasets
  - Often require GPUs or distributed computing

### **Interpretability**
- **Simple models** like:
  - Linear Regression
  - Logistic Regression (Logistic regression is a statistical method designed for binary classification problems)
  - Decision Trees  
  Are **easier to explain** and **regulatory compliant**

## Summary Table

| Factor          | Favor Simpler Models           | Favor Complex Models              |
|----------------|--------------------------------|----------------------------------|
| Use Case       | Regulatory compliance          | High accuracy needed             |
| Performance    | Good, but limited              | High with large data             |
| Interpretability| High (e.g., Logistic Regression)| Low (e.g., Deep Learning)         |
| Scalability    | Fast on small/medium data      | Optimized for large-scale ML     |
| Examples       | Decision Trees, Linear Models  | CNNs, XGBoost, Transformers      |

# Considerations for Interpretability in Model Selection

## What is Interpretability?

**Interpretability** is the ability of humans to **understand the reasoning** behind a machine learning model‚Äôs prediction or output.

- Important in high-stakes domains like **banking**, **insurance**, and **medicine**
- Builds **trust** with users
- Helps meet **compliance** requirements from government and regulatory agencies

## Importance of Interpretability

### üîç Business Transparency
- Clients and stakeholders must understand model decisions.
- Promotes **accountability** and **trust** in ML systems.

### Regulatory Compliance
- In sectors like **insurance**, **healthcare**, and **finance**, regulations demand clear decision logic.
- Regulatory bodies (e.g., **BSP** in the Philippines) enforce **fair and explainable** AI practices.

## Tools & Techniques for Model Explainability

### SageMaker Clarify
- Detects **bias** and delivers **explainability reports**
- Works **before and after model training**
- Seamlessly integrates with SageMaker pipelines

Using Amazon SageMaker Clarify to run bias reports on both the training data and the model‚Äôs predictions is the best approach to effectively identify and mitigate bias. This method provides a comprehensive analysis of fairness by measuring pre-training bias in the dataset and post-training bias in the model outputs.

### SHAP (SHapley Additive exPlanations)
- Assigns importance to each feature in a prediction
- Offers **global and local interpretability**

### LIME (Local Interpretable Model-Agnostic Explanations)
- Provides simple explanations for **individual predictions**
- Works across all model types

## Summary Table

| Aspect                  | Description                                               |
|--------------------------|-----------------------------------------------------------|
| Business Transparency    | Helps users understand why a decision was made            |
| Regulatory Compliance    | Meets legal requirements for AI interpretability          |
| SageMaker Clarify        | AWS tool for bias + model explainability                  |
| SHAP                     | Feature importance per prediction                         |
| LIME                     | Simple explanation for individual decisions               |

# Cost Considerations in Model Selection

When building ML solutions, **cost** is a major factor. This includes training, inference, infrastructure, and storage.

## Cost Evaluation with AWS SageMaker

### Training Cost Optimization
- **SageMaker charges per compute and storage usage**
- Use **Spot Instances** to reduce training costs by **up to 90%**
- Spot instances are ideal for hyperparameter tuning jobs because they offer significant cost savings and are suitable for workloads that can tolerate interruptions.

## SageMaker JumpStart for Cost-Effective ML

### What is JumpStart?
- A **no-code/low-code** solution with **pre-trained models**
- Eliminates the need for extensive training from scratch

### How JumpStart Helps Reduce Costs

| Benefit | Description |
|--------|-------------|
| ‚úÖ Less Compute Resources | No need to train from scratch; use pre-trained models |
| ‚úÖ No Large Datasets | Skip costly data labeling; fine-tune with smaller datasets |
| ‚úÖ On-Demand Deployment | Use AWS-managed endpoints and pay only when in use |

### Methods available in Jumpstart

- Fine-tuning a pre-trained model with their own dataset enables the team to improve the model‚Äôs performance for their specific task, making it more suitable for their use case.

- Prompt engineering allows the team to fine-tune the inputs provided to the model, guiding it to produce more relevant responses for their specific use case. 

## Summary Table

| Strategy                    | Cost Benefit                                 |
|-----------------------------|----------------------------------------------|
| Spot Instances              | Up to 90% savings on training compute        |
| Pre-trained Models (JumpStart) | Skip expensive model training               |
| On-Demand Endpoints         | Pay-per-use (billed per second)              |
| Fewer Labeling Requirements | No need for manual annotation services       |
| Lightweight Infrastructure  | No EC2 or Kubernetes setup required          |

# Model Ensembling

## Model Ensembling Techniques
Combining predictions from multiple models to improve accuracy and robustness.

- **Bagging (Bootstrap Aggregating)**  
  Trains many weak models independently and averages their predictions.  
  *Example:* Random Forest.

- **Boosting**  
  Trains models sequentially where each new model focuses on correcting errors from previous ones.  
  *Example:* XGBoost, AdaBoost.

  Boosting is the best-suited ensemble method for reducing both bias and variance while enabling flexible modeling of complex data behaviors. 

- **Stacking**  
  Combines outputs from multiple models and inputs them into a final meta-model for prediction.

  Stacking is the most effective method to combine logistic regression, decision tree, and support vector machine models because it leverages the complementary strengths of each base model by training a meta-model on their predictions. This approach improves overall accuracy and robustness beyond what simple voting, bagging, or boosting (especially with heterogeneous models) can achieve.
